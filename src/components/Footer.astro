---
import '../styles/global.css';
import '../styles/footer.css';
---

<!-- TODO: Consider moving the entire footer logic into its own navbar component --><!-- todo: consider updating this an ID -->
<footer class="wrapper">
  <!-- TODO: might need to update the name -->
  <div class="menu-container">
    <nav class="menu">
      <button class="menu__item active"><a href="/" class="menu__item-text">home</a></button>
      <button class="menu__item"><a class="menu__item-text">projects</a></button>
      <button class="menu__item"><a class="menu__item-text">work</a></button>
      <button class="menu__item"><a class="menu__item-text">moodboard</a></button>
      <button class="menu__item"><a href="/memorabilia" class="menu__item-text">memorabilia</a></button>
      <button class="menu__item"><a class="menu__item-text">email</a></button>
      <button class="menu__item"><a class="menu__item-text">github</a></button>
      <div class="menu__dot"></div>
    </nav>
    <div class="menu__border"></div>
  </div>
  <div class="svg-container">
    <svg viewBox="0 0 202.9 45.5">
      <clipPath id="menu" clipPathUnits="objectBoundingBox" transform="scale(0.0049285362247413 0.021978021978022)">
        <path
          d="M6.7,45.5c5.7,0.1,14.1-0.4,23.3-4c5.7-2.3,9.9-5,18.1-10.5c10.7-7.1,11.8-9.2,20.6-14.3c5-2.9,9.2-5.2,15.2-7
          c7.1-2.1,13.3-2.3,17.6-2.1c4.2-0.2,10.5,0.1,17.6,2.1c6.1,1.8,10.2,4.1,15.2,7c8.8,5,9.9,7.1,20.6,14.3c8.3,5.5,12.4,8.2,18.1,10.5
          c9.2,3.6,17.6,4.2,23.3,4H6.7z"
        ></path>
      </clipPath>
    </svg>
  </div>
</footer>
<script>
  document.addEventListener('astro:page-load', () => {
    const menu = document.querySelector('.menu') as HTMLElement;
    const menuItems = document.querySelectorAll('.menu__item');
    const menuDot = document.querySelector('.menu__dot') as HTMLElement;
    const menuBorder = document.querySelector('.menu__border') as HTMLElement;
    let isScrolling = false;

    // Function to handle initial positioning
    function initPositioning() {
      const activeItem = document.querySelector('.menu__item.active') as HTMLElement;
      if (activeItem) {
        handleBorderPosition(menuBorder, menu, activeItem);
        moveDot(activeItem);
      }
    }

    // TODO: investigate if this can be implemented on startup
    // and then saved throughout application lifecycle
    function setActiveMenuItem() {
      const currentPath = window.location.pathname;

      let foundActive = false;
      menuItems.forEach((item) => {
        const link = item.querySelector('a') as HTMLAnchorElement;

        if (link && link.getAttribute('href') === currentPath) {
          item.classList.add('active');
          foundActive = true;
        } else {
          item.classList.remove('active');
        }
      });

      if (!foundActive && menuItems.length > 0) {
        menuItems[0].classList.add('active');
      }
    }

    function handleClick(item: Element) {
      let activeItem = document.querySelector('.menu__item.active');
      if (item === activeItem || !activeItem) return;

      activeItem.classList.remove('active');
      item.classList.add('active');

      activeItem = item;

      // Enable animation on click
      menuBorder.style.transition = 'transform var(--timeOut, var(--duration))';

      handleBorderPosition(menuBorder, menu, activeItem);
      moveDot(item, true);
    }

    function handleBorderPosition(menuBorder: HTMLElement, menu: HTMLElement, activeItem?: Element) {
      activeItem = activeItem || (document.querySelector('.active') as Element);
      const activeItemPosition = activeItem.getBoundingClientRect();

      const { left, width } = activeItemPosition;
      const menuLeft = menu.getBoundingClientRect().left;

      // Adjust the border's position relative to the active item's position and menu's scroll
      const moveRight = Math.floor(left - menuLeft - (menuBorder.offsetWidth - width) / 2) + 'px';
      menuBorder.style.transform = `translateX(${moveRight})`;
    }

    function moveDot(activeItem: Element, shouldAnimate = false) {
      const { left, width } = activeItem.getBoundingClientRect();
      const menuLeft = menu.getBoundingClientRect().left;

      // Get the scroll position of the menu
      const scrollLeft = menu.scrollLeft;

      // Adjust the dot position calculation to include the menu's scroll position
      const moveX = Math.floor(left - menuLeft + scrollLeft + width / 2 - 4) + 'px';

      // Update the dot position
      menuDot.style.setProperty('--dotPosition', moveX);

      // Only trigger animation if shouldAnimate is true
      if (shouldAnimate) {
        menuDot.classList.remove('active');
        // Wait for the next animation frame to re-add the active class and re-trigger the animation
        requestAnimationFrame(() => {
          menuDot.classList.add('active');
        });
      }
    }

    // Handle border movement on scroll
    menu.addEventListener('scroll', () => {
      if (!isScrolling) {
        // Disable animation during scroll
        menuBorder.style.transition = 'none';
        isScrolling = true;
      }

      const activeItem = document.querySelector('.menu__item.active') as HTMLElement;
      handleBorderPosition(menuBorder, menu, activeItem);
      moveDot(activeItem, false); // No animation on scroll

      // Set a delay to allow for scrolling to finish
      // otherwise the menu border will flicker
      setTimeout(() => {
        isScrolling = false;
      }, 150); // Adjust the delay as needed
    });

    // Resize event to adjust position on window resize
    window.addEventListener('resize', () => {
      const activeItem = document.querySelector('.menu__item.active') as HTMLElement;
      moveDot(activeItem, false); // No animation on resize
      handleBorderPosition(menuBorder, menu);
    });

    menuItems.forEach((item) => {
      item.addEventListener('click', () => handleClick(item));
    });

    setActiveMenuItem();
    initPositioning();
  });
</script>
